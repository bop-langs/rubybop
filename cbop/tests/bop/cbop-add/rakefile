target = "add"
cc = "gcc"
c_flags = "-g3 " # -fno-toplevel-reorder seems not useful
ldflags = "-lm "  # -no_order_data seems not useful

c_sources = ["#{target}.c"]
objs = FileList.new(c_sources).ext('.o')

# dir/file => dir/prefix_file
require 'pathname'  # Pathname
def add_prefix(file, prefix)
  return file if prefix == nil
  pn = Pathname.new(file)
  return pn.dirname.to_s+"/"+"#{prefix}_#{pn.basename.to_s}"
end  
seq_objs = objs.collect {|n| add_prefix(n, "seq")}
noprot_objs = objs.collect {|n| add_prefix(n, "noprot")}
bop_objs = objs.collect {|n| add_prefix(n, "bop")}

# build the bop version

bop_name =  "#{target}_bop"
bop_dir = "~/orig_rubybop/cbop/INST/"
bop_lib = bop_dir+"inst.a"

# use a procedure in order to access bop_dir variable
build_lib = Proc.new do
  sh "cd #{bop_dir}; rake"
end

task_bop = file bop_name => objs + [bop_lib] do
  build_lib.call
  sh "#{cc} #{ldflags} -o #{bop_name} #{bop_objs * ' '} #{bop_dir}/inst.a"
end

task :bop do
  build_lib.call
  task_bop.invoke
end

# the sequential BOP version, with BOP actions but ppr tasks execute sequentially
# the debugging version, like seq but does not protect memory pages

seq_name = "#{target}_seq"
noprot_name = "#{target}_noprot"

task_seq = file seq_name => objs + [bop_lib] do
  sh "#{cc} #{ldflags} -o #{seq_name} #{seq_objs * ' '} #{bop_dir}/seq_inst.a"
  sh "#{cc} #{ldflags} -o #{noprot_name} #{noprot_objs * ' '} #{bop_dir}/noprot_inst.a -lpthread" 
end

rule '.o' => '.c' do |t|
  sh "gcc #{c_flags} -I#{bop_dir} -c -o #{t.name} #{t.source}" 
  sh "gcc -DBOP #{c_flags} -I#{bop_dir}/.. -c -o #{add_prefix(t.name, "bop")} #{t.source}" 
  sh "gcc -DBOP_SEQ #{c_flags} -I#{bop_dir}/.. -c -o #{add_prefix(t.name, "seq")} #{t.source}"
  sh "gcc -DBOP_SEQ -DBOP_NOPROT #{c_flags} -I#{bop_dir}/.. -c -o #{add_prefix(t.name, "noprot")} #{t.source}"
end

task :seq do
  build_lib.call
  task_seq.invoke
end

# the BOP-less version

orig_name = "#{target}_orig"

task_orig = task :orig => [orig_name]

file orig_name => objs do
  sh "#{cc} #{ldflags} -o #{orig_name} #{objs * ' '}"
end

task_clean = task :clean do
  (objs + bop_objs + seq_objs + noprot_objs).each {|obj| sh "\\rm #{obj}" if File.file?(obj)}
#  tmp_dirs = Dir.entries(".").find_all {|n| n.include?("dSYM")}
#  tmp_dirs.each do |dnm|
#    sh "\\rm -rf #{dnm}"
#  end
end

real_clean = task :realclean do
  task_clean.invoke
  [seq_name, noprot_name, bop_name, orig_name].each do |fnm|
    sh "\\rm #{fnm}" if File.file?(fnm)
  end
end

task_all = task :all do
  build_lib.call
  task_orig.invoke
  task_seq.invoke
  task_bop.invoke
  # task_clean.invoke
end

task :force do
  real_clean.invoke
  task_all.invoke
end

task :default do
  task_all.invoke
end

task :run_seq do
  build_lib.call
  task_seq.invoke
  args = ARGV.slice(1,ARGV.length-1).join(" ")
  sh "./#{seq_name} #{args}"
end
